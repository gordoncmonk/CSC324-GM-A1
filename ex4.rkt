#lang racket #| CSC324 Fall 2018: Exercise 4 |#
#|
* Before starting, please review the exercise guidelines at
http://www.cs.toronto.edu/~lczhang/324/assignments.html *
|#
;-------------------------------------------------------------------------------
(provide calculate eval-calc analyze-strictness)

;-------------------------------------------------------------------------------
; * Task 1: Eager Evaluation *
;-------------------------------------------------------------------------------

#|
(calculate expr)
  expr: A datum representing an expression generated by the
        grammar in the Exericse 4 handout
|#
(define (calculate expr)
  (eval-calc expr (hash)))

#|
(eval-calc expr env)
  expr: A datum representing an expression generated by the
        grammar in the Exercise 4 handout
  env:  A hash table representing an environment.
        The keys of the hash table are symbols representing identifiers.

  You may assume that if an `expr` is an identifier, then it is present in `env`.
|#

(define (hash-setter bindings env)
  (if (null? bindings)
      null
      (if (number? (second bindings))
          (hash-set env (first bindings) (second bindings))
          (if (list? (second bindings))
              (hash-set env (first bindings) (eval-calc (second bindings) env))
              (hash-set env (first bindings) (hash-ref env (second bindings) (second bindings)))
              ;(hash-set env (first bindings) (dict-ref env (second bindings)))
              )
          )
      )
  )

(define ( (map-calc env) expr)               ;Helper function that's a curry of eval-calc to allow me to map
  (eval-calc expr env)
  )

(define (list-merger lst1 lst2) ;Merges the two lists so I can use the same hash-function
  (cond
    [(null? lst1)     ; If the first list is empty
     #;(lst2)
     '()]           ; ... return the second list.
    [(null? lst2)     ; If the second list is empty
     #;(lst1)
     '()]           ; ... return the first list.
    [else        ; If both lists are non-empty
     (append (list (first lst1)) (append (list (first lst2)) (list-merger (rest lst1) (rest lst2)))) 
     ]
    )  ; ... make a recursively call, advancing over the first
  ; ... list, inverting the order used to pass the lists.
  )

(define (list-setup lst) ;Adds the list pairs together so I can use the same hash-function
  (cond
    [(null? lst) '()]
    [else (append (list (list (first lst) (second lst))) (list-setup (rest (rest lst))))]
    )
  )

(define (eval-calc expr env)
  (cond              
    [(null? expr) null]
    [(list? expr) (cond
                    [(equal? (first expr) 'if)
                     (cond
                       ; =
                       [(equal? ( first (second expr)) '=) (cond
                                                             [(equal? (eval-calc (second (second expr)) env) (eval-calc (third (second expr)) env) ) (third expr)]
                                                             [else (fourth expr)])
                                                           ]
                       ; >
                       [(equal? ( first (second expr)) '>) (cond
                                                             [(> (eval-calc (second (second expr)) env) (eval-calc (third (second expr)) env) ) (third expr)]
                                                             [else (fourth expr)])
                                                           ]
                       ; <
                       [(equal? ( first (second expr)) '<) (cond
                                                             [(< (eval-calc (second (second expr)) env) (eval-calc (third (second expr)) env) ) (third expr)]
                                                             [else (fourth expr)])
                                                           ]
                       )]
                    [(equal? (first expr) 'let*)
                     (eval-calc (third expr) (foldl hash-setter env (second expr)))

                     ]

                    
                    #|
#;((lambda (a) (+ a 1)) 4))
  ;            Result = 5
4 = Argument(s)

((lambda (a) (+ a 1) )4)
/\
Function Body?

                    (calculate '(let* ( (f (lambda (x) (+ 1 x))) ) (f 1)))
'(closure (lambda (x) (+ 1 x)) #hash())
(eval-calc ((third (second expr))) (hash-setter (list-setup (list-merger (second (second expr)) (rest (third expr))))
|#
                  
                    [(equal? (first expr) '+) (+ (eval-calc (second expr) env) (eval-calc (third expr) env) )]
                    [(equal? (first expr) '-) (- (eval-calc (second expr) env) (eval-calc (third expr) env) )]
                    [(equal? (first expr) '*) (* (eval-calc (second expr) env) (eval-calc (third expr) env) )]
                    [(equal? (first expr) '/) (/ (eval-calc (second expr) env) (eval-calc (third expr) env) )]
                    
                    [(equal? (first expr) 'lambda) ; Function Expression / Defining Function
                     (list 'closure expr env)]
                    
                    [else
                     
                     #|
                    (if ;(equal? 'closure (first (eval-calc (third expr) (hash-setter (second expr) ))))
                      (list? (eval-calc (third expr) (hash-setter (second expr) ))) ;Assume that first returns closure
                      (let ([expr2 (eval-calc (third expr) (hash-setter (second expr) ))]) 
                        (eval-calc (third (second expr2)) (hash-setter (list-setup (list-merger (second (second expr2)) (rest (third expr))))))
                              )

                           ;(second (second expr2)) = '(x)
                           ; (rest (third expr)) = '(1)
                           ; (hash-setter (...) = #hash((x . 1))
                           ; (third (second expr2)) = '(+ 1 x)
                           
                      (eval-calc (third expr) (hash-setter (second expr) ))
                      )

(hash-ref env (eval-calc (first expr) env) (eval-calc (first expr) env))
             ;        |#
                     ; This is the skeleton body of my code
                     #;(hash-ref env (eval-calc (first expr) env) (eval-calc (first expr) env))
                     ;This statement fails when a value of the hash is a closure (because of the way hash works it doesn't turn out well...

                     ;(let* ([closure (eval-calc (first expr) env)])
;'(closure (lambda (a x) (lambda (a) (x a))) #hash(())
;'(closure (lambda (x y) (* (+ x y) n)) #hash((n . 10)))
                     
                     (let* ([closure (hash-ref env (eval-calc (first expr) env) (eval-calc (first expr) env))])
                       ;(first closure)
                       ; Contract Violation
                       ;expr
                        ;(calculate '(let* ((f (lambda (a x) (lambda (a) (x a))))) ((f 9 (lambda (x) x) ) 1)))
                      ;(list? closure)
                       ;closure
                           (eval-calc (third (second closure)) (foldl hash-setter (third closure) (list-setup (list-merger (second (second closure)) (map (map-calc env) (rest expr)))) ))
                           )
                     ;'(closure (lambda (a x) (lambda (a) (x a))) #hash())
                     ;(third (eval-calc (first expr) env))

                           ;[else (hash-ref env expr expr)]
                     
                     #|
                     #;(if (equal? 'closure (first (eval-calc (first(expr)) env)))
                         (eval-calc (second expr) env)   ; args
                         (eval-calc (third expr) env)    ; args
                         ; Need to get params and body from closure (evaluate body from closure using fenv, bind params to value of args)
                         ; Binding process could most likely be done using a call to rest and maybe foldl (Might have done this in my helper functions
                         ; Once my values are bounded I add these to my fenv hash (the one from the closure)and evaluate the body
                         (second (eval-calc (first expr) env)) ; list of params
                         (third (eval-calc (first expr) env)) ; Function body
                         ; Since I'm calling the same function over the expression a lot I should probably bind this to a value (so I don't call function
                         ; Over and over again.
                         ; Should hide this in a let* statement
                         ; Maybe have variables

                         (hash-setter (list-setup (list-merger (second (second expr2)) (rest (third expr))))) ; Should merge the two lists/bodies

                         

                         (let* ([closure (eval-calc (first expr) env)])
                               (if (equal? 'closure (first closure))
                                   
                                     ; Body is (third (second closure))
                                     ; fenv = (third closure)
                                     ; params = (second (second closure))
                                   
                                     (hash-setter (list-setup (list-merger (params) (map (map-calc env) (rest expr)))))
                                     ; Need to merge the above hash with fenv

                     |#

                     ]
                    )]
    [(number? expr) expr]
    [else (hash-ref env expr expr)]
    ;[else expr]
    
    )
  )

(module+ test
    (require rackunit)
    ; You should write more tests to make sure that your
    ; interpreter uses lexical scoping


      #|   Uncomment this block to see if your fix works with old test-cases:


    (test-equal? "Function definition"
                 (calculate '((lambda (a) (+ a 1)) 4))
                 5)
    (test-equal? "Functions with multiple arguments"
                 (calculate '((lambda (a b) (+ b 1)) 4 14))
                 15)
    (test-equal? "lambda + let"
                 (calculate '((lambda (a b) (+ a b)) (let* ((b 3)) (+ b 2)) 4))
                 9)
    (test-equal? "FunctionCall"
                 (calculate '(lambda (x) (+ x 1)))
                 '(closure (lambda (x) (+ x 1)) #hash())
                 )

    (test-equal? "If statements with bindings"
                 (calculate '(let* ((a 3) (b 3)) (if (= a b) 1 0)))
                 1)
    (test-equal? "Recursive bindings"
                 (calculate '(let* ((a 3) (a (+ a 1))) (* a 2)))
                 8)

      
  
    (test-equal? "let first"
                 (calculate '(let* ( (f (lambda (x) (+ 1 x))) ) (f 1)))
                 2)
    ; After let, I need to call (apply (eval-calc (hash-ref f env) 1)
    ; Generalized, it looks like I call eval-calc on the last parameter with the 2nd being the actual env
    ; If this is the case, then I will need something

; |#
    #;(test-equal? "random test"       ;Fails
                 (calculate '(let* ((f (lambda (a x) (lambda (a) (x a))))) ((f 9 (lambda (x) x) ) 1)))
                 1)
  #;(test-equal? "y-combinator!"      ;Fails
               (calculate '(let* ((fix (lambda (f) ((lambda (d) (d d)) (lambda (x) (f (lambda (a) ((x x) a))))))) (fac (fix (lambda (fac) (lambda (n) (if (= n 0) 1 (* n (fac (- n 1))))))))) (fac 5)))
               120)
#|
  
  (test-equal? "return 10"
               (calculate '(let* ((n 10)
                                  (f (lambda (x) n))
                                  (g (lambda (n) (f 3))))
                             (g 100)))
               10)

  (test-equal? "return 12"
               (calculate '((lambda (a b) (let* ((b 7)) (+ a b))) 5 14))
               12)
  
  (test-equal? "rando2"
               (calculate '(let* ((f (lambda (x) (+ x 1))))(f 5)))
               6)
  (test-equal? "Lexical Scoping"                                  ; Passes, miswrote the test
                 (calculate '((lambda (x)
                              (let* ((addx (lambda (a) (+ a x))))
                                ((lambda (x y) (addx y)) 10 20))) 
                              5))
                 25)
  (test-equal? "lex scope2"      ;Passes
               (calculate '(let* ((x 5)
       (addx (lambda (a) (+ a x))))
     ((lambda (x y) (addx y)) 10 20)))
               25)

|#
  )
;-------------------------------------------------------------------------------
; * Task 1: Strictness analysis *
;-------------------------------------------------------------------------------
#|
(analyze-strictness func-defs)
  func-defs:
      A datum representing a program as specified by the grammar on the handout.
      (In this case, it's a list of function definitions.)

  Returns a *strictness map*, which is a hash table mapping function names (as symbols)
  to a list of indexes of the strict parameters of that function.
  Each list should be in increasing order.

  Remember, you may assume that the program has no syntactic or semantic errors
  (so you don't even need to watch out for things like duplicate names).

  Hash table reference: https://docs.racket-lang.org/reference/hashtables.html.

  Implementation hints:
    1. Same as Exercise 3, the main work can be done by processing the list of
       function definitions in a call to foldl.
    2. Working with list indexes is a bit more annoying in pure functional land.
       Use the list function `indexes-where`, which is similar to `filter` except
       it returns indexes rather than elements.
|#
(define (analyze-strictness func-defs)
  (define table (hash))
  ; (first func-defs) = 'define
  ; (first (second func-defs)) = Function Name
  ; Want to run (rest (second funct-defs)) through exp)
  ; (strict-in? s-map id expr)
  
  ; (indexes-where list proc)
  (hash-set table (first (second (first func-defs)))
            (indexes-where (rest (second (first func-defs))) (binary-helper table (first(rest (rest (first func-defs)))) )     )  
            )

        ; Binary-helper: (s-map expr) id - returns if positive
            
;(indexes-where (rest (second (first func-defs))) (binary-helper table (rest (rest (first func-defs)))))
  

  ;foldl proc init lst
  )
;(curry_test s-map id )
; funct-defs = '((define (f x) 5)))
;                
                                                            
; ///////

#|
Language Grammar

<prog> = <function-def> ..1 (One or more function definitions
<function-def> = (define (ID ID ...) <expr> ) # The first ID is the function name
                                              #any others are function parameters

<expr> = NUMBER
       | ID
       | (if <expr> <expr> <expr> ) # Same syntax as Racket
       | (ID <expr> ... )           # Function call, where the first expression
                                    # MUST be an identifier

|#


; ///////

#|
(strict-in? s-map id expr)
  s-map: A strictness map
  id: An identifier
  expr: A quoted expression in the grammar specified by the assignment handout.

  Returns whether id is strict in the given expression.
  Uses the given strictness map to determine strictness in function calls.

  NOTE: this function isn't being tested explicitly, so you may freely change it or
  ignore it for this exercise.

  Implementation hint:
    Remember that `and` and `or` aren't function identifiers: you can't pass them to
    HOFs like `map` or `apply`. But you can use functions like `andmap` and `ormap`
    to achieve similar effects.
|#
(define ((binary-helper s-map expr) id)
  (positive? (strict-in? s-map id expr))
  
  )
(define ((curry_test s-map id) expr)
  (+ (strict-in? s-map id expr))
  )

(define (strict-in? s-map id expr)
  ;(void)
  ;To Check for Strictness I'll most likely need conds and go case-by-case
  ; We are checking if id is strict in the expr
  ; s-map is used to determine strictness in function calls.
  
  (cond [(null? expr) 0 ]    ;Instead of false, might want to return 0
        [(number? expr) 0] 
        [(list? expr)    ;A list is either a function call or an if statement
         (cond [(equal? (first expr) id) 1]
               [(equal? (first expr) 'if) ; Finish if Expression check
                (cond [(> (strict-in? s-map id (second expr)) 0) 1]              ;Must be strict in condition
                      [(> (+ (strict-in? s-map id (third expr)) (strict-in? s-map id (fourth expr)) ) 1) 1] ;Must be strict in both cases (no boolean)
                      #;(if (andmap (binary-helper s-map id) ((rest (rest expr)))); Doesn't look like my binary helper works
                            0
                            1)
                      [else 0])                                           ;Not Strict
                ]
               ; Function Calls

               ; + Operator
               [(equal? (first expr) '+) #;(if (ormap (binary-helper s-map id) (rest expr))
                                               ;(> (foldl + 0 (strict-in? s-map id (rest expr)) ) 0)
                                               ; This is the ormap case
                                               1
                                               0
                                               )
                                         ;(if (> (foldl (compose + (curry_test s-map id ) )   0 (rest expr))  0)
                                         (let ([x (foldl + 0 (map (curry_test s-map id ) (rest expr)) )])
                                           (if (> x 0)
                                               1
                                               0)
                                           )
                                         #;(if (> (foldl + 0 (map (curry_test s-map id ) (rest expr)) )  0)
                                               1
                                               0)
                                         ; Might want to set this up recursively
                                         
                                         ]
               ; Other Function Calls    ;This is having issues cause I can't do function calls...
               [else (cond
                         [(equal? id (first expr)) 1]
                         ;  X is Strict in argument SubExpression of E and that argument is strict in parameter of F
                         ; This means X is strict in E, and E is strict in F
                         ;[( > (strict-in? s-map 'x expr ) 0) 1 ]
                         [(if (and ( > (strict-in? s-map id (rest expr) ) 0) (equal? (indexes-where (expr) id ) (hash-ref s-map (first expr) ) ))
                              1
                              0)]
                         [else 0]
                         ;(strict-in? s-map id (second (first expr))) map strict-in for rest of list to get at least one of them being 1?


                         )]
               ;[else expr]
               )]
        [else (if (equal? id expr)
                  1
                  0)]
        ; Assuming functional grammar is correct, noting else should be accounted for
        
        )
  )

#;(module+ test
  (require rackunit)

  (test-equal? "Test1"
               (strict-in? (hash) 'x '(+ 1 2 x))
               1)

  (test-equal? "Test2"
               (strict-in? (hash) 'x '(+ 1 2 9))
               0)
  ; Returns 90 which is my inner else case
  ; This means that it is reading ('x) 
  )
  
;Uncomment this later?
(module+ test
    (require rackunit)

    (test-equal? "Not Strict"
                 (analyze-strictness '((define (f x) 5)))
                 (hash
                  'f (list )))
    
    (test-equal? "Identity function"
                 (analyze-strictness '((define (f x) x)))
                 (hash
                  'f (list 0)))

    (test-equal? "One function, with if (1)"
                 (analyze-strictness '((define (f x) (if x 3 5))))
                 (hash
                  'f (list 0)))

    (test-equal? "One function, with +"
                 (analyze-strictness '((define (f x y z) (+ x y))))
                 (hash
                  'f (list 0 1)))
    )
